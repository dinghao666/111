## 动态规划算法

### 1.应用场景

- 背包问题：有一个背包，容量为4kg，现有如下物品

| 物品 | 重量 | 价格 |
| :--: | :--: | :--: |
|  A   |  1   | 1500 |
|  B   |  4   | 3000 |
|  C   |  3   | 2000 |

（1） 要求达到的目标为装入背包的总价值最大，并且重量不超出

（2）要求装入的物品不能重复

### 2.动态规划算法介绍

- 核心思想

将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

与分治法不同的是，动态规划算法求解的问题，经过分解得到子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行上一步的求解）

动态规划可以通过填表的方式来逐步推进，得到最优解

### 3.背包问题的求解

```java
public class PackageProblem {
    public static void main(String[] args) {
        int[] w = {1,5,3,2};
        int[] val = {100,300,200,150};
        int m = 6;
        int n = w.length;
        int[][] vmax=new int[n+1][m+1];

        for (int i = 0;i <= m;i++){
            vmax[0][i] = 0;
        }
        for (int i = 0; i <= n; i++) {
            vmax[i][0] = 0;
        }
        //背包问题的解决
        for (int i = 1;i <= n;i++){
            for (int j = 1;j <= m;j++){
                if (w[i-1] > j){  //如果要放入的物品的重量大于目前背包容量，就回归上一个策略
                    vmax[i][j] = vmax[i-1][j];
                }else {  //如果放入的物品的重量小于等于目前背包容量，先试着放入，和上个策略比较哪种策略更优
                    vmax[i][j] = Math.max(vmax[i-1][j],val[i-1]+vmax[i-1][j-w[i-1]]);
                }
            }
        }
        //输出表格
        for (int i = 0;i <= n;i++){
            for (int j = 0;j <= m;j++){
                System.out.print(vmax[i][j]+"   ");
            }
            System.out.println();
        }
    }
}
```

| 物品/重量 |  0   |  1   |  2   |  3   |     4     |
| :-------: | :--: | :--: | :--: | :--: | :-------: |
|           |  0   |  0   |  0   |  0   |     0     |
|     A     |  0   | 1500 | 1500 | 1500 |   1500    |
|     B     |  0   | 1500 | 1500 | 1500 |   3000    |
|     C     |  0   | 1500 | 1500 | 1500 | 2000+1500 |

用val[i]和w[i]分别表示第i个物品的价值和重量，vmax[i] [j]表示前**i**个物品放入容量为**j**的背包的最大价值。

将背包容量拆分为最小单位，从第一个物品开始放入，利用循环

```java
for (int i = 1;i <= n;i++){
            for (int j = 1;j <= m;j++){
                if (w[i-1] > j){  //如果要放入的物品的重量大于目前背包容量，就回归上一个策略
                    vmax[i][j] = vmax[i-1][j];
                }else {  //如果放入的物品的重量小于等于目前背包容量，先试着放入，和上个策略比较哪种策略更优
                    vmax[i][j] = Math.max(vmax[i-1][j],val[i-1]+vmax[i-1][j-w[i-1]]);
                }
            }
        }
```

将vmax的第二行算出来，此时的vmax[1] [jmax] (jmax表示背包容量最大值)代表的一定是前1个物品放入背包产生的价值，依次类推。**这里的重点在于判断即将放入的物品重量是否能够放入背包，如果不能，就回归上个策略的最大值，能的话则放入，并且和上个策略的最大值比较，选取更大的一个**

